# QuickSight용 Retail Data - product 번역



**Bedrock을 활용하여 products.csv에 있는 product_name을 시작으로 다른 _name 한국어 제품명을 영어로 바꾸는 program**





### product_name만 번역

```
import boto3
import pandas as pd
import json

def translate_product_names(input_text):
    session = boto3.Session()
    bedrock = session.client(service_name='bedrock-runtime')
    
    prompt = f"\n\nHuman: Translate the following product names from Korean to English:\n{input_text}\n\nAssistant:"
    
    response = bedrock.invoke_model(
        modelId="anthropic.claude-v2",
        body=json.dumps({
            "prompt": prompt,
            "max_tokens_to_sample": 2000,
            "temperature": 0
        })
    )
    
    response_body = json.loads(response['body'].read().decode('utf-8'))
    translations = response_body['completion'].strip()
    
    # 번역 결과에서 불필요한 텍스트 제거
    translations = translations.replace("Here are the English translations:", "").strip()
    
    # 번역된 이름을 리스트로 변환
    translated_list = [name.strip() for name in translations.split('\n') if name.strip()]
    
    return translated_list

try:
    # CSV 파일 읽기
    df = pd.read_csv('10.csv')
    print(f"Number of rows in DataFrame: {len(df)}")

    # product_name 열 추출
    product_names = df['product_name'].tolist()

    # 번역을 위해 product_name을 문자열로 결합
    names_to_translate = "\n".join(product_names)

    # Bedrock을 사용하여 번역
    translated_names = translate_product_names(names_to_translate)

    # 번역된 이름의 수가 원본 데이터와 일치하지 않을 경우 처리
    if len(translated_names) != len(df):
        print(f"Warning: Number of translations ({len(translated_names)}) does not match number of products ({len(df)})")
        if len(translated_names) < len(df):
            translated_names.extend([''] * (len(df) - len(translated_names)))
        else:
            translated_names = translated_names[:len(df)]

    # 새로운 열 'product_name_en'에 번역된 이름 추가
    df['product_name_en'] = translated_names

    # 결과를 new.csv 파일로 저장
    df.to_csv('new.csv', index=False)
    print("Results saved to new.csv")

except Exception as e:
    print(f"An error occurred: {str(e)}")

```





### 3개 번역 버전

```
import boto3
import pandas as pd
import json

def translate_columns(input_text):
    session = boto3.Session()
    bedrock = session.client(service_name='bedrock-runtime')
    
    prompt = f"\n\nHuman: Translate the following Korean terms to English:\n{input_text}\n\nAssistant:"
    
    response = bedrock.invoke_model(
        modelId="anthropic.claude-v2",
        body=json.dumps({
            "prompt": prompt,
            "max_tokens_to_sample": 2000,
            "temperature": 0
        })
    )
    
    response_body = json.loads(response['body'].read().decode('utf-8'))
    translations = response_body['completion'].strip()
    
    # Remove any unwanted prefixes or text
    if "Here are the English translations for the Korean terms:" in translations:
        translations = translations.replace("Here are the English translations for the Korean terms:", "").strip()
    
    # Split and clean up translations
    translated_list = [name.strip() for name in translations.split('\n') if name.strip()]
    
    return translated_list

try:
    # Read CSV file
    df = pd.read_csv('10.csv')
    print(f"Number of rows in DataFrame: {len(df)}")

    # Columns to translate
    columns_to_translate = ['division_name', 'maincategory_name', 'subcategory_name', 'product_name']

    for column in columns_to_translate:
        # Extract unique values for translation
        unique_values = df[column].unique()
        
        # Combine values into a string for translation
        values_to_translate = "\n".join(unique_values)

        # Translate using Bedrock
        translated_values = translate_columns(values_to_translate)

        # Create a dictionary mapping original values to their translations
        translation_dict = dict(zip(unique_values, translated_values))

        # Create new column names
        new_column_name = f"{column}_en"

        # Map translated values to new column
        df[new_column_name] = df[column].map(translation_dict)

    # Save results to new.csv file
    df.to_csv('new.csv', index=False)
    print("Results saved to new.csv")

except Exception as e:
    print(f"An error occurred: {str(e)}")

```



### Sonnet 3.5 	

```
import boto3
import pandas as pd
import json

def translate_columns(input_text):
    session = boto3.Session()
    bedrock = session.client(service_name='bedrock-runtime')
    
    prompt = f"Translate the following Korean terms to English:\n{input_text}\n"
    
    body = {
        "anthropic_version": "bedrock-2023-05-31",
        "max_tokens": 2000,
        "messages": [
            {
                "role": "user",
                "content": prompt
            }
        ],
        "temperature": 0
    }
    
    try:
        response = bedrock.invoke_model(
            modelId="anthropic.claude-3-sonnet-20240229-v1:0",
            body=json.dumps(body)
        )
        
        response_body = json.loads(response['body'].read().decode('utf-8'))
        translations = response_body['content'][0]['text'].strip()
        
        # Split and clean up translations
        translated_list = [name.strip() for name in translations.split('\n') if name.strip()]
        
        return translated_list
    
    except Exception as e:
        print(f"An error occurred during translation: {e}")
        return []

try:
    # Read CSV file
    df = pd.read_csv('10.csv')
    print(f"Number of rows in DataFrame: {len(df)}")

    # Columns to translate
    columns_to_translate = ['division_name', 'maincategory_name', 'subcategory_name', 'product_name']

    for column in columns_to_translate:
        # Extract unique values for translation
        unique_values = df[column].unique()
        
        # Combine values into a string for translation
        values_to_translate = "\n".join(unique_values)

        # Translate using Claude 3.5 Sonnet
        translated_values = translate_columns(values_to_translate)

        # Create a dictionary mapping original values to their translations
        translation_dict = dict(zip(unique_values, translated_values))

        # Create new column names
        new_column_name = f"{column}_en"

        # Map translated values to new column
        df[new_column_name] = df[column].map(translation_dict)

    # Save results to new.csv file
    df.to_csv('new.csv', index=False)
    print("Results saved to new.csv")

except Exception as e:
    print(f"An error occurred: {str(e)}")

```





```

```



